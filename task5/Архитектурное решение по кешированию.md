# Мотивация

Компания испытывает серьёзные проблемы с производительностью MES, что негативно сказывается на опыте операторов и клиентов:

1. Страница новых заказов в MES загружается слишком долго, несмотря на введённую пагинацию и фильтрацию.

2. Нагрузка на базу данных MES растёт, что усугубляет замедления.

3. Операторы испытывают демотивацию из-за задержек, а клиенты жалуются на просрочки и потерю заказов.

Кеширование - способ снизить нагрузку на базу данных и ускорить отклик системы для часто запрашиваемых данных, таких как список новых заказов.

В системе можно выделить следующие части для кеширования:

1. Список новых заказов для операторов MES (часто запрашивается и обновляется не мгновенно).

2. Информация о статусах заказов для отображения на дашборде.

Кеширование позволит:

1. Уменьшить количество запросов к базе данных MES.
2. Снизить время отклика страниц MES.
3. Улучшить пользовательский опыт операторов и клиентов.


# Предлагаемое решение

Реализуем серверное кеширование на уровне MES API. Клиентское кеширование в браузере не решит проблему высокой нагрузки на сервер и базу данных. Серверное кеширование позволит централизованно контролировать данные и их актуальность.

- Используем паттерн Cache-Aside. Cache-Aside позволяет приложению самостоятельно решать, когда читать из кеша, а когда из базы данных. 

- Также используем Write-Through. При создании нового заказа данные сразу записываются и в базу данных, и в кеш. 

- Можно использовать Redis как распределённый in-memory кеш. MES API будет обращаться к Redis при запросе списка новых заказов. 

## Диаграмма последовательности Pluntuml, отображающая работу с кешем:

@startuml

actor API_User as api_user
participant MES_API as mes_api
participant Redis as redis_cache
participant MES_DB as mes_db


api_user -> mes_api: Запрос на создание заказа
activate mes_api

mes_api -> mes_db: Создает заказ в MES_DB
activate mes_db
mes_db --> mes_api: ОК
deactivate mes_db

mes_api -> redis_cache: Запись данных о заказе в кеш (Write-Through)
activate redis_cache
redis_cache --> mes_api: ОК
deactivate redis_cache

mes_api --> api_user: ОК
deactivate mes_api


actor Operator as operator
operator -> mes_api: Запрос списка новых заказов
mes_api -> redis_cache: Проверка кеша новых заказов (Cache-Aside)
activate redis_cache
alt Cache hit
    redis_cache --> mes_api: Возвращаем список новых заказов из кеша
    deactivate redis_cache
else Cache miss
    redis_cache --> mes_api: Нет данных
    deactivate redis_cache
    mes_api -> mes_db: Запрашиваем список новых заказов из MES_DB
    activate mes_db
    mes_db --> mes_api: Возвращаем список новых заказов
    deactivate mes_db
    mes_api -> redis_cache: Записываем список новых заказов в кеш
    activate redis_cache
    redis_cache --> mes_api: ОК
    deactivate redis_cache
end
mes_api --> operator: Возвращаем список новых заказов


operator -> mes_api: Изменяем статус заказа (на MANUFACTURING_STARTED)
activate mes_api
mes_api -> mes_db: Обновляем статус в MES_DB
activate mes_db
mes_db --> mes_api: ОК
deactivate mes_db
mes_api -> redis_cache: Инвалидируем кеш
activate redis_cache
redis_cache --> mes_api: ОК
deactivate redis_cache
mes_api --> operator: ОК
deactivate mes_api

@enduml


## Инвалидация кеша: 

- Используем программную инвалидацию. При изменении статуса заказа (например, переход в MANUFACTURING_STARTED) MES API будет программно инвалидировать кеш, чтобы новые заказы актуально отображались. 

- Остальные методы ("Инвалидация, основанная на запросах", "Инвалидация на основе изменений", "Инвалидация по ключу" - показались менее подходящими). 

 